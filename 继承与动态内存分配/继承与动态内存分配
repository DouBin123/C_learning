类设计回顾：
1、构造函数，在创建对象时，通过该函数给类的私有成员赋值
	默认构造函数：在没有定义构造函数时
		如果在派生类的构造函数的成员初始化列表中没有显式调用基类构造函数
		则编译器将使用基类的默认构造函数来构造派生类对象的基类部分。
	一般（显式）构造函数，需要给类的私有成员赋初值或者动态内存分配时
派生类的对象在创建之前要首先执行基类的构造函数
	复制构造函数（对象过期会调用析构函数）：接受其所属类的对象或对象引用作为参数
		1、将新对象初始化为一个同类对象；
		2、按值将对象传递给函数
		3、函数按值返回对象
		4、编译器生成临时对象
	临时对象通常产生于以下4种情况：类型装换、按值传递、按值返回、对象定义
2、赋值运算符
	默认的赋值运算符主要用于处理同类对象之间的赋值，修改已有的对象的值
	在使用之前考虑清除左值对象的内容。
3、析构函数：一定要定义显式的虚构函数释放构造函数使用new分配的所有内存
	对于基类，即使它不需要析构函数，也应该提供虚析构函数（virtual）动态联编
4、转换（自动向上，禁止向下）：
	格式：operator typename();//可隐式可显式
	定义构造函数时（一个未知参数作隐式转换）：BaseClass(const char*)//convert char* to baseclass
    explicit Star(const char*)//禁止隐式转换，允许显式转换
5、按值传递与按引用传递（按引用传递）
6、按值返回和按引用返回
    一般按引用返回
	在返回临时对象时只能按值返回
7、使用const
8、友元（friend）：并非类成员，不能继承，可以访问类的私有成员。
	如果希望通过派生类的友元函数使用基类的友元函数，可以通过强制类型转换将派生类的引用或指针转换为基类引用或指针，借此来调用基类的友元函数
9、虚方法（virtual）：希望派生类中能够重新定义基类函数或者使用动态联编（多态性）
10、ABC接口：  class expendclass  :public  baseclass{……纯虚方法（=0）};
纯虚函数在ABC类中声明，没有函数实现，一般在派生类中实现（函数体）
11、protected是相对于派生类的一个概念，派生类的成员可以直接访问基类的保护成员，但不能访问基类的私有成员。
由protected声明的成员称为“受保护的成员”，或简称“保护成员”。从类的用户角度来看，保护成员等价于私有成员。但有一点与私有成员不同，保护成员可以被派生类的成员函数引用。
12、static
