//通常，编译器使用三块独立的内存：一块用于静态变量，一块用于自动变量（栈），另一块用于动态存储（堆）
//************存储持续性*************
/*
自动存储持续性（栈）：函数中声明的一般变量，局部作用域，函数运行时存在
			register（寄存器）：显式指出自动变量
			注意auto在C++11后用于自动类型推断
静态存储持续性（固定的内存块）：函数定义外定义的变量或static定义的变量，程序运行过程中一直存在
			外部链接性(函数外变量)：可在其他文件中访问
				引用声明（不初始化）：extern,在多个文件中使用外部变量，则只需要定义一次，但在引用的文件中要引用声明
			内部链接性（static）：只能在当前文件中访问
			同一变量在同一文件中只能定义一次（单定义规则），但可以使用static定义静态外部变量，在该文件中静态变量将隐藏常规外部变量
			无链接性(函数中static)：只能在当前函数或代码块中访问，适于再生，只初始化一次
			局部变量与全局变量为同名时，局部变量将隐藏全局变量
线程存储持续性：thread_local，生命周期与所属线程一样长
动态存储持续性：new分配的，自由存储或堆
*/
//使变量不冲突的几种办法
/*
1、静态  static 只在当前文件或函数中有效，并且会隐藏重名的外部变量
2、引用  extern （没重新定义）=原外部变量
         extern  （重新定义）--局部变量，隐藏原外部变量
*/
//***************说明符与限定符******************
/*
register:指示寄存器存储
static：作用域为整个文件时，表示内部链接性；用于局部声明时，局部变量的存储持续性是静态的
extern:引用声明，其他地方定义的变量
thread_local:变量的持续性与所属线程的持续性相同
*/
//*******************  cv限定符 *****
/*
const:使全局变量的链接性变为内部性
volatile（不稳定的）:代码即使没有对内存单元修改，其值也可能发生改变
mutual（成员限定符）：即使结构体或类为const，其某个成员也可以被修改
*/
