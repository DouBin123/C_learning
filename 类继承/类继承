//类继承：
/*
类库是以源代码的方式提供的，可以修改，但C++提供了一种比修改代码更好的方法来扩展和修改类，称为类继承。
1、在已有类的基础上添加功能
2、给类添加数据
3、可以修改类方法
表示方法：
	派生类：public 基类
	{
	……
	};
派生类对象存储了基类的数据成员（派生类继承了基类的实现）
派生对象可以使用基类的方法（派生类继承了基类的接口）
1、派生类需要自己的构造函数
2、派生类可以根据需要添加额外的数据成员和成员函数。
	class  RatedPlayer: public TableTennisPlayer
	{
	private:
		usigned int rating;
	public:
		RatedPlayer(unsigned int r=0,const string & fn="none",const string &ln="none",bool ht=false);//派生类构造函数，不能直接访问基类的数据成员，只能通过基类的成员函数。
		RatedPlayer(unsigned intr,const TableTennisPlayer &tp);//通过基类的复制构造函数赋值
		unsigned int Rating() const{return rating;}
		void ResetRating(unsigned int r){rating=r;}
	}
基类对象在程序进入派生类构造函数之前被创建。
RatedPlayer::RetaedPlayer(unsigned int r,const string &fn,const string &ln,bool ht):TableTennisPlayer(fn,ln,ht)
{
	rating=r;
}
或
RatedPlayer(unsigned intr,const TableTennisPlayer &tp):TableTennisPlayer(tp)
{
	rating=r;
}
1、首先创建基类对象
2、派生类构造函数应通过初始化列表将基类信息传递给基类构造函数。
3、派生类构造函数应初始化派生类新增的数据成员

注意：创建派生类对象时，程序首先调用基类构造函数，然后再调用派生类构造函数。基类构造函数负责初始化继承的数据成员；
派生类构造函数主要用于初始化新增的数据成员。派生类的构造函数总是调用一个基类构造函数。可以使用初始化器列表语法指明要使用的基类构造函数，
否则将使用相应的默认构造（复制构造函数）函数。派生类对象过期时，程序将首先调用派生类析构函数，然后再调用基类析构函数。
	derived::derived(type1 x,type2 y):base (x,y)
	{
	……
	}
*/
//基类和派生类之间的特殊关系
/*
1、派生类对象可以使用基类的方法
2、基类指针可以在不进行显式类型转换的情况下指向派生类对象。
	但不可以将基类对象和地址赋给派生类指针和引用。基类包含派生类
	对于形参为指向基类的指针的函数，可以使用基类对象的地址或派生类对象的地址作为实参。
*/
//************************继承：is-a关系************************
/*
is-a====is a kind of：A----->B（单向）
常见的关系：
	has a:午餐有水果，但水果不一定是午餐
	is like(像) a:律师像鲨鱼，但律师并不是鲨鱼
	is implemented as a(作为……来实现):数组可以实现栈，但是栈不是数组
	uses a：计算机可以使用打印机，但从计算机派生打印机无意义
多态公有继承：同一个方法在派生类和基类中的行为是不同的
	1、在派生类中重新定义基类的方法
	2、使用虚方法（程序将根据引用或指针的对象选择方法）
*/
//*************************联编***********************8
/*
将源代码中的函数调用解释为执行特定的函数代码块被称为函数名联编
在编译过程中进行联编被称为静态联编，又称为早期联编
由于虚函数的引进使得编译器的选择变得复杂，编译器必须生成能够在程序运行时选择正确的虚方法的代码称为动态联编，又称为晚期联编
静态联编比动态联编更合理也更高效。
1、如果要在派生类中重新定义基类的方法，则设为虚方法，否则设非虚。
//指针与引用的兼容性
	将派生类引用或指针转换为基类引用或指针被称为向上强制转换，是继承的特性。可以隐式转换，但是向下转换必须显式。
	虚函数的形参分别为基类值，引用，指针时，基类对象和派生类对象调用虚函数时，只有指针和引用会发生隐式的向上转换呈现多态性
	按值传递导致只将派生类对象的基类部分传递给虚函数。
*/
//*************************虚函数*********************
/*
虚函数表：保存了指向所有基类函数与虚函数的地址数组的指针，在定义基类或者在派生类定义虚函数时才会更新
基类对象包含一个指针，该指针指向基类中所有虚函数的地址表（vtbl），派生类对象将包含一个指向独立地址表的指针。
如果派生类提供了虚函数的新定义，该虚函数表（派生对象的独立地址表）将保存新函数的地址，否则不更新。
使用虚函数的成本：
	1、每个对象都将增大，增大量为存储地址的空间
	2、对于每一个类，编译器将创建一个虚函数地址表
	3、对于每个函数调用，都需要执行一项额外的操作，即到表中查找地址
注意：
1、在基类方法的声明中使用关键字virtual可以使该方法在基类以及所有的派生类中是虚的
2、如果使用指针或引用（对象的），程序将使用为对象类型定义的方法，而不使用为引用或指针类型定义的方法，即动态联编。
3、如果定义的类将被用作基类，则应将那些要在派生类中定义的类方法声明为虚的。
4、构造函数不能为虚，析构函数一般为虚，友元不能为虚。
5、(virtual)重新定义将隐藏方法，可以将返回值类型改为派生类对象引用（返回类型协变）
*/
//*****************访问控制：protected**********************
/*
protected是相对于派生类的一个概念，派生类的成员可以直接访问基类的保护成员，但不能访问基类的私有成员。
*/
//*****************抽象基类（ABC:abstrct base class）***************
/*
至少使用一个纯虚的接口（=0），包含纯虚函数的类只能用作基类，它是集多个类的共性于一体，它不能创建对象，可以管理多个类
ABC=class1 交 class2
*/
//***************************继承与动态内存分配*****************
/*
1、派生类不使用new
	假设基类使用了动态内存分配，派生类未使用new，则不需要为派生类显式定义析构函数，复制构造函数和赋值运算符
2、派生类使用new
	假设派生类使用了new（*p）,必须为派生类显式定义析构函数，复制构造函数和赋值运算符
*/
