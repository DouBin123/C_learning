//静态类成员有一个特点：无论创建了多少对象，
//只创建一个静态变量副本，即所有的对象共享一个静态成员
//**************C风格字符串*******************
/*
假设要将字符串作为参数传递给函数，则表示字符串的方式有三种
1、char 数组
2、用引号括起来的字符串常量
3、被设为字符串的地址的char指针（char*）
char ghost[15]="galloping";
char *str="global";
int n1=strlen(ghost);
int n2=strlen(str)
int n3=strlen("my bad day");
*/
//*******************类成员中有指针时**********
/*
构造函数的参数为字符串指针时，字符串并不保存在对象中。字符串
单独保存在堆中，对象仅保存了指出要去哪里查找字符串的信息。
每个对象的成员应该是独立的，而不能共享堆中的数据，可以在初始化时将堆中数据通过指针及new拷贝过来，
在对象以后的操作可能会改变其中的成员，相当于副本的作用，增加程序安全性。
必须定义复制构造函数，计数更新，深度复制
*/
//************特殊成员函数***************
/*
默认构造函数，如果没有定义构造函数，只能有一个，否则会有二义性
默认析构函数，如果没有定义，在创建对象（构造函数创建和复制构造函数创建时）后，对象过期时会调用，因此
	需要增加复制构造函数被调用的计数，即提供计数可更新的显式复制构造函数和深度复制，使每个对象都有自己的字符串（地址）而不是
	其他对象的引用
复制构造函数(函数按值传递)，如果没有定义
	如果有一个已经定义的对象motto，则下面两张方式会调用：
	String1 ditto(motto)和String1 metto=motto;
	逐个复制非静态成员
	成员函数返回对象时（返回局部对象时不能使用引用返回），调用复制构造函数，但返回引用不会
赋值运算符，如果没有定义，经常与复制构造函数的出现相关
	由于目标对象（左值）可能引用了以前分配的数据，应该用delete []释放
	避免将对象赋值给自身
	返回引用
地址运算符，如果没有定义，返回调用对象的地址即this指针的值
移动构造函数
移动赋值运算符
*/
//***************标准输入流***************
/*
使用 cin 从标准输入读取数据时，通常用到的方法有 cin>>、cin.get()，cin.getline()。
	当我们从键盘输入字符串的时候需要敲一下回车键才能够将这个字符串送入到缓冲区中，
	那么敲入的这个回车键（\r）会被转换为一个换行符（\n），这个换行符也会被存储在 cin 
	的缓冲区中并且被当成一个字符来计算！比如我们在键盘上敲下了 123456 这个字符串，
	然后敲一下回车键（\r）将这个字符串送入了缓冲区中，那么此时缓冲区中的字节个数是 7 ，
	而不是 6。
cin>>:
	当 cin>> 从缓冲区中读取数据时，若缓冲区中第一个字符是空格、tab或换行这些分隔符时，
	cin>> 会将其忽略并清除，继续读取下一个字符，若缓冲区为空，则继续等待。但是如果读取成功，
	字符后面的分隔符是残留在缓冲区的，cin>> 不做处理。
	不想略过空白字符，那就使用 noskipws 流控制。比如 cin>>noskipws>>input;
cin.get(char)
	cin.get() 从输入缓冲区读取单个字符时不忽略分隔符，直接将其读取
	cin.get() 的返回值是 int 类型，成功则返回读取字符的 ASCII 码值
cin.get(char*s arsize )
	遇到换行符时结束读取，但是不对换行符进行处理，换行符仍然残留在输入缓冲区。
	将截取输入缓存区中的前n位
cin.get(char* arsize delim)
	指定读取的行数
cin.getline()
	cin.getline 读取一行字符时，默认遇到 ‘\n’ 时终止，并且将 ‘\n’ 直接从输入缓冲区中删除掉，不会影响下面的输入处理。
//*************状态与清除***********
goodbit(0x0)：无错误
eofbit(0x1)：已到达文件尾
failbit(0x2)：非致命的输入/输出错误，可挽回
badbit(0x4)：致命的输入/输出错误，无法挽回
与这些条件状态对应的就是设置、读取和判断条件状态的流对象的成员函数：
	s.eof()：若流 s 的 eofbit 置位，则返回 true
	s.fail()：若流 s 的 failbit 置位，则返回 true
	s.bad()：若流 s 的 badbit 置位，则返回 true
	s.good()：若流 s 的 goodbit 置位，则返回 true
	s.clear(flags)：清空当前状态, 然后把状态设置为 flags，返回 void
	s.setstate(flags)：不清空当前状态，设置给定的状态 flags，返回 void
	s.rdstate()：返回流 s 的当前条件状态，返回值类型为 ios_base::iostate
getline()
	getline() 利用 cin 可以从标准输入设备键盘读取一行，当遇到如下三种情况会结束读操作：
	文件结束\遇到行分隔符/输入达到最大限度。
	getline() 函数的参数使用了 string 字符串.
gets()
	gets() 是 C 中的库函数，在头文件 <stdio.h> 申明，从标准输入设备读字符串，可以无限读取，不会判断上限，以回车或者文件结束符 EOF（ 即 -1） 结束
*/
//*********************使用new初始化对象***************
/*
Class_name *pclass= new Class_name（value）;
会调用构造函数：Class_name(Type_name);
		new用于为对象分配内存（1个或多个），也就是为保存字符串指针和len成员分配，这里是一个对象的内存，故用delete不是delete[]
	调用的构造函数为存储字符串分配内存
	用new创建的对象在显式使用delete时才会调用析构函数
其他new:
	Type_name *p=new Type_name [N];
	必须用delete[]，堆
	定位new:定位 new，就是预先分配一块内存，再将 new 出来的对象放入此内存块中的方法。通俗点说，就是在指定内存块中产生新对象
		Type_name *p=new (Arr_name) Type_name [N];
		Type_name *p=new (Arr_name) Type_name
		不需要delete，每次调用使用相同内存块
	对于定位new创建的对象，应该以与创建顺序相反的顺序进行删除
*/
//******************************指针与对象****************
/*
1、常规声明对象的指针
	String1 *glamour;
2、可以将指针初始化为指向已有的对象
	String1 *first=& sayings[0];
3、可以使用new来初始化指针，这将创建一个新对象
	String1 *pveg= new String("cabbag heads home");
	1.为对象分配内存：str:--,len:---
	2.调用类构造函数：
		为"cabbag heads home"分配空间，将"cabbag heads home"复制到分配的内存中
		将"cabbag heads home"地址给str,将长度给len，更新静态变量num_strings
	3.创建pveg变量
	4.将新对象的地址给pveg
4、对类使用new将调用相应的构造函数来初始化创建的对象
	String1 *gl=new String1;
5、可以使用->运算符通过指针访问类方法；
	sayings[i].length()=shortest->length();
6、可以使用解除引用运算符*来获得对象
	sayings[i]=*first;		
*/
